import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged, filter } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { Directive, Injectable, Component, ContentChild, Input, TemplateRef, ViewEncapsulation, NgModule, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';
import { ActivatedRoute, NavigationEnd, Router, RouterModule } from '@angular/router';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This directive is used to customize the breadcrumb label behavior
 * *xngBreadcrumbItem directive can be used in the child element of xng-breadcrumb
 * Usage: refer to demo app.component.html
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@angular/common';

function BreadcrumbComponent_ng_container_2_a_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function BreadcrumbComponent_ng_container_2_a_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const breadcrumb_r47 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(breadcrumb_r47.label);
} }
const _c0 = function (a0) { return [a0]; };
const _c1 = function (a0) { return { "xng-breadcrumb-link-disabled": a0 }; };
const _c2 = function (a0, a1, a2, a3) { return { $implicit: a0, info: a1, last: a2, first: a3 }; };
function BreadcrumbComponent_ng_container_2_a_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 7);
    ɵngcc0.ɵɵtemplate(1, BreadcrumbComponent_ng_container_2_a_2_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_a_2_ng_container_2_Template, 2, 1, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r56 = ɵngcc0.ɵɵnextContext();
    const breadcrumb_r47 = ctx_r56.$implicit;
    const isLast_r48 = ctx_r56.last;
    const isFirst_r49 = ctx_r56.first;
    const ctx_r50 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("routerLink", ɵngcc0.ɵɵpureFunction1(8, _c0, breadcrumb_r47.routeLink))("ngClass", ɵngcc0.ɵɵpureFunction1(10, _c1, breadcrumb_r47.disable))("queryParams", breadcrumb_r47.queryParams)("fragment", breadcrumb_r47.fragment);
    ɵngcc0.ɵɵattribute("aria-disabled", breadcrumb_r47.disable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r50.itemTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction4(12, _c2, breadcrumb_r47.label, breadcrumb_r47.info, isLast_r48, isFirst_r49));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r50.itemTemplate);
} }
function BreadcrumbComponent_ng_container_2_label_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function BreadcrumbComponent_ng_container_2_label_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const breadcrumb_r47 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(breadcrumb_r47.label);
} }
function BreadcrumbComponent_ng_container_2_label_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 10);
    ɵngcc0.ɵɵtemplate(1, BreadcrumbComponent_ng_container_2_label_3_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_label_3_ng_container_2_Template, 2, 1, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r60 = ɵngcc0.ɵɵnextContext();
    const breadcrumb_r47 = ctx_r60.$implicit;
    const isLast_r48 = ctx_r60.last;
    const isFirst_r49 = ctx_r60.first;
    const ctx_r51 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r51.itemTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction4(3, _c2, breadcrumb_r47.label, breadcrumb_r47.info, isLast_r48, isFirst_r49));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r51.itemTemplate);
} }
function BreadcrumbComponent_ng_container_2_li_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function BreadcrumbComponent_ng_container_2_li_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r62 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r62.separator);
} }
function BreadcrumbComponent_ng_container_2_li_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 11);
    ɵngcc0.ɵɵtemplate(1, BreadcrumbComponent_ng_container_2_li_4_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_li_4_ng_container_2_Template, 2, 1, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r52 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r52.separatorTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r52.separatorTemplate);
} }
function BreadcrumbComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "li", 3);
    ɵngcc0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_a_2_Template, 3, 17, "a", 4);
    ɵngcc0.ɵɵtemplate(3, BreadcrumbComponent_ng_container_2_label_3_Template, 3, 8, "label", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, BreadcrumbComponent_ng_container_2_li_4_Template, 3, 2, "li", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const isLast_r48 = ctx.last;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !isLast_r48);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", isLast_r48);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !isLast_r48);
} }
class BreadcrumbItemDirective {
    constructor() { }
}
BreadcrumbItemDirective.ɵfac = function BreadcrumbItemDirective_Factory(t) { return new (t || BreadcrumbItemDirective)(); };
BreadcrumbItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BreadcrumbItemDirective, selectors: [["", "xngBreadcrumbItem", ""]] });
/** @nocollapse */
BreadcrumbItemDirective.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BreadcrumbItemDirective, [{
        type: Directive,
        args: [{
                selector: '[xngBreadcrumbItem]'
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BreadcrumbService {
    /**
     * @param {?} activatedRoute
     * @param {?} router
     */
    constructor(activatedRoute, router) {
        this.activatedRoute = activatedRoute;
        this.router = router;
        this.baseHref = '/';
        /**
         * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.
         * Breadcrumbs can be set from anywhere (component, service) in the app.
         * On every breadcrumb update check this store and use the info if available.
         */
        this.dynamicBreadcrumbStore = [];
        /**
         * breadcrumbList for the current route
         * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected
         * If effected, update the change and emit a new stream
         */
        this.currentBreadcrumbs = [];
        this.previousBreadcrumbs = [];
        /**
         * Breadcrumbs observable to be subscribed by BreadcrumbComponent
         * Emits on every route change OR dynamic update of breadcrumb
         */
        this.breadcrumbs = new BehaviorSubject([]);
        this.breadcrumbs$ = this.breadcrumbs.asObservable();
        this.pathParamPrefix = ':';
        this.pathParamRegexIdentifier = '/:[^/]+';
        this.pathParamRegexReplacer = '/[^/]+';
        this.setBaseBreadcrumb();
        this.detectRouteChanges();
    }
    /**
     * Update breadcrumb label or options for -
     *
     * route (complete route path). route can be passed the same way you define angular routes
     * 1) update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')
     * 2) change visibility Ex: set('/mentor/:id/edit', { skip: true })
     * 3) add info Ex: set('/mentor/:id/edit', { info: { icon: 'edit', iconColor: 'blue' } })
     * ------------------------ OR -------------------------
     *
     * alias (prefixed with '\@'). breadcrumb alias is unique for a route
     * 1) update label Ex: set('\@mentor', 'Enabler')
     * 2) change visibility Ex: set('\@mentorEdit', { skip: true })
     * 3) add info Ex: set('\@mentorEdit', { info: { icon: 'edit', iconColor: 'blue' } })
     * @param {?} pathOrAlias
     * @param {?} breadcrumb
     * @return {?}
     */
    set(pathOrAlias, breadcrumb) {
        if (!this.validateArguments(pathOrAlias, breadcrumb)) {
            return;
        }
        if (typeof breadcrumb === 'string') {
            breadcrumb = {
                label: breadcrumb
            };
        }
        if (pathOrAlias.startsWith('@')) {
            this.updateStore(Object.assign({}, breadcrumb, { alias: pathOrAlias.slice(1) }));
        }
        else {
            /** @type {?} */
            const breadcrumbExtraProps = this.buildRouteRegExp(pathOrAlias);
            this.updateStore(Object.assign({}, breadcrumb, breadcrumbExtraProps));
        }
    }
    /**
     * @private
     * @return {?}
     */
    setBaseBreadcrumb() {
        /** @type {?} */
        const baseConfig = this.router.config.find((/**
         * @param {?} pathConfig
         * @return {?}
         */
        pathConfig => pathConfig.path === ''));
        if (baseConfig && baseConfig.data) {
            let { label, alias, skip = false, info, disable = false } = this.getBreadcrumbOptions(baseConfig.data);
            /** @type {?} */
            let isAutoGeneratedLabel = false;
            if (typeof label !== 'string' && !label) {
                label = '';
                isAutoGeneratedLabel = true;
            }
            this.baseBreadcrumb = {
                label,
                alias,
                skip,
                disable,
                info,
                routeLink: this.baseHref,
                isAutoGeneratedLabel
            };
        }
    }
    /**
     * Whenever route changes build breadcrumb list again
     * @private
     * @return {?}
     */
    detectRouteChanges() {
        this.router.events
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event instanceof NavigationEnd)), distinctUntilChanged())
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this.previousBreadcrumbs = this.currentBreadcrumbs;
            this.currentBreadcrumbs = this.baseBreadcrumb ? [this.baseBreadcrumb] : [];
            this.prepareBreadcrumbList(this.activatedRoute.root, this.baseHref);
        }));
    }
    /**
     * @private
     * @param {?} activatedRoute
     * @param {?} routeLinkPrefix
     * @return {?}
     */
    prepareBreadcrumbList(activatedRoute, routeLinkPrefix) {
        if (activatedRoute.routeConfig && activatedRoute.routeConfig.path) {
            /** @type {?} */
            const breadcrumbItem = this.prepareBreadcrumbItem(activatedRoute, routeLinkPrefix);
            this.currentBreadcrumbs.push(breadcrumbItem);
            if (activatedRoute.firstChild) {
                return this.prepareBreadcrumbList(activatedRoute.firstChild, breadcrumbItem.routeLink + '/');
            }
        }
        else if (activatedRoute.firstChild) {
            return this.prepareBreadcrumbList(activatedRoute.firstChild, routeLinkPrefix);
        }
        // remove breadcrumb items that needs to be hidden or don't have a label
        /** @type {?} */
        const breadcrumbsToShow = this.currentBreadcrumbs.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => !item.skip));
        this.breadcrumbs.next(breadcrumbsToShow);
    }
    /**
     * @private
     * @param {?} activatedRoute
     * @param {?} routeLinkPrefix
     * @return {?}
     */
    prepareBreadcrumbItem(activatedRoute, routeLinkPrefix) {
        const { path, breadcrumb } = this.parseRouteData(activatedRoute.routeConfig);
        // in case of path param get the resolved for param
        /** @type {?} */
        const resolvedPath = this.resolvePathParam(path, activatedRoute);
        /** @type {?} */
        const routeLink = `${routeLinkPrefix}${resolvedPath}`;
        let { label, alias, skip, disable, info } = this.getFromStore(breadcrumb.alias, routeLink);
        /** @type {?} */
        let isAutoGeneratedLabel = false;
        if (typeof label !== 'string') {
            if (typeof breadcrumb.label === 'string') {
                label = breadcrumb.label;
            }
            else {
                label = resolvedPath;
                isAutoGeneratedLabel = true;
            }
        }
        return Object.assign({ label, alias: alias || breadcrumb.alias, skip: skip || breadcrumb.skip, disable: disable || breadcrumb.disable, info: info || breadcrumb.info, routeLink,
            isAutoGeneratedLabel }, this.resolveQueryParam(routeLink, activatedRoute));
    }
    /**
     * For a specific route, breadcrumb can be defined either on parent data OR it's child(which has empty path) data
     * When both are defined, child takes precedence
     *
     * Ex: Below we are setting breadcrumb on both parent and child.
     * So, child takes precedence and "Defined On Child" is displayed for the route 'home'
     * { path: 'home', loadChildren: './home/home.module#HomeModule' , data: {breadcrumb: "Defined On Module"}}
     *                                                AND
     * children: [
     *   { path: '', component: ShowUserComponent, data: {breadcrumb: "Defined On Child" }
     * ]
     * @private
     * @param {?} routeConfig
     * @return {?}
     */
    parseRouteData(routeConfig) {
        const { path, data = {} } = routeConfig;
        /** @type {?} */
        const breadcrumb = this.mergeWithBaseChildData(routeConfig, Object.assign({}, data));
        return { path, breadcrumb };
    }
    /**
     * @private
     * @param {?} breadcrumbAlias
     * @param {?} routeLink
     * @return {?}
     */
    getFromStore(breadcrumbAlias, routeLink) {
        /** @type {?} */
        let matchingItem;
        if (breadcrumbAlias) {
            matchingItem = this.dynamicBreadcrumbStore.find((/**
             * @param {?} item
             * @return {?}
             */
            item => item.alias === breadcrumbAlias));
        }
        if (!matchingItem && routeLink) {
            matchingItem = this.dynamicBreadcrumbStore.find((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return (item.routeLink && item.routeLink === routeLink) || (item.routeRegex && new RegExp(item.routeRegex).test(routeLink + '/'));
            }));
        }
        return matchingItem || {};
    }
    /**
     * To update breadcrumb label for a route with path param, we need regex that matches route.
     * Instead of user providing regex, we help in preparing regex dynamically
     *
     * Ex: route declaration - path: '/mentor/:id'
     * breadcrumbService.set('/mentor/:id', 'Uday');
     * '/mentor/2' OR 'mentor/ada' we should use 'Uday' as label
     *
     * regex string is built, if route has path params(contains with ':')
     * @private
     * @param {?} path
     * @return {?}
     */
    buildRouteRegExp(path) {
        // ensure leading slash is provided in the path
        if (!path.startsWith('/')) {
            path = '/' + path;
        }
        if (path.includes(this.pathParamPrefix)) {
            // replace mathing path param with a regex
            // '/mentor/:id' becomes '/mentor/[^/]', which further will be matched in updateStore
            /** @type {?} */
            const routeRegex = path.replace(new RegExp(this.pathParamRegexIdentifier, 'g'), this.pathParamRegexReplacer);
            return { routeRegex };
        }
        else {
            return { routeLink: path };
        }
    }
    /**
     * Update current breadcrumb definition and emit a new stream of breadcrumbs
     * Also update the store to reuse dynamic declarations
     * @private
     * @param {?} breadcrumb
     * @return {?}
     */
    updateStore(breadcrumb) {
        const { breadcrumbItemIndex, storeItemIndex } = this.getBreadcrumbIndexes(breadcrumb);
        // if breadcrumb is present in current breadcrumbs update it and emit new stream
        if (breadcrumbItemIndex > -1) {
            this.currentBreadcrumbs[breadcrumbItemIndex] = Object.assign({}, this.currentBreadcrumbs[breadcrumbItemIndex], breadcrumb);
            /** @type {?} */
            const breadcrumbsToShow = this.currentBreadcrumbs.filter((/**
             * @param {?} item
             * @return {?}
             */
            item => !item.skip));
            this.breadcrumbs.next([...breadcrumbsToShow]);
        }
        // If the store already has this route definition update it, else add
        if (storeItemIndex > -1) {
            this.dynamicBreadcrumbStore[storeItemIndex] = Object.assign({}, this.dynamicBreadcrumbStore[storeItemIndex], breadcrumb);
        }
        else {
            this.dynamicBreadcrumbStore.push(breadcrumb);
        }
    }
    /**
     * @private
     * @param {?} breadcrumb
     * @return {?}
     */
    getBreadcrumbIndexes(breadcrumb) {
        const { alias, routeLink, routeRegex } = breadcrumb;
        /** @type {?} */
        let indexMap = {};
        // identify macthing breadcrumb and store item
        if (alias) {
            indexMap = this.getBreadcrumbIndexesByType('alias', alias);
        }
        else if (routeLink) {
            indexMap = this.getBreadcrumbIndexesByType('routeLink', routeLink);
        }
        else if (routeRegex) {
            indexMap = this.getBreadcrumbIndexesByType('routeRegex', routeRegex);
        }
        return indexMap;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    getBreadcrumbIndexesByType(key, value) {
        /** @type {?} */
        let breadcrumbItemIndex;
        if (key !== 'routeRegex') {
            breadcrumbItemIndex = this.currentBreadcrumbs.findIndex((/**
             * @param {?} item
             * @return {?}
             */
            item => value === item[key]));
        }
        else {
            breadcrumbItemIndex = this.currentBreadcrumbs.findIndex((/**
             * @param {?} item
             * @return {?}
             */
            item => new RegExp(value).test(item.routeLink)));
        }
        /** @type {?} */
        const storeItemIndex = this.dynamicBreadcrumbStore.findIndex((/**
         * @param {?} item
         * @return {?}
         */
        item => value === item[key]));
        return { breadcrumbItemIndex, storeItemIndex };
    }
    /**
     * @private
     * @param {?} path
     * @param {?} activatedRoute
     * @return {?}
     */
    resolvePathParam(path, activatedRoute) {
        // if the path segment is a route param, read the param value from url
        if (path.startsWith(this.pathParamPrefix)) {
            return activatedRoute.snapshot.params[path.slice(1)];
        }
        return path;
    }
    /**
     * @private
     * @param {?} routeLink
     * @param {?} activatedRoute
     * @return {?}
     */
    resolveQueryParam(routeLink, activatedRoute) {
        /** @type {?} */
        const previousBreadcrumb = this.previousBreadcrumbs.find((/**
         * @param {?} item
         * @return {?}
         */
        item => item.routeLink === routeLink)) || {};
        const { queryParams, fragment } = activatedRoute.snapshot;
        return {
            queryParams: Object.keys(queryParams).length > 0 ? Object.assign({}, queryParams) : previousBreadcrumb.queryParams,
            fragment: fragment || previousBreadcrumb.fragment
        };
    }
    /**
     * get empty children of a module or Component. Empty child is the one with path: ''
     * When parent and it's children (that has empty route path) define data
     * merge them both with child taking precedence
     * @private
     * @param {?} routeConfig
     * @param {?} data
     * @return {?}
     */
    mergeWithBaseChildData(routeConfig, data) {
        if (!routeConfig) {
            return this.getBreadcrumbOptions(data);
        }
        /** @type {?} */
        let baseChild;
        if (routeConfig.loadChildren) {
            // To handle a module with empty child route
            baseChild = routeConfig._loadedConfig.routes.find((/**
             * @param {?} route
             * @return {?}
             */
            route => route.path === ''));
        }
        else if (routeConfig.children) {
            // To handle a component with empty child route
            baseChild = routeConfig.children.find((/**
             * @param {?} route
             * @return {?}
             */
            route => route.path === ''));
        }
        return baseChild && baseChild.data
            ? this.mergeWithBaseChildData(baseChild, Object.assign({}, this.getBreadcrumbOptions(data), this.getBreadcrumbOptions(baseChild.data)))
            : this.getBreadcrumbOptions(data);
    }
    /**
     * @private
     * @param {?} pathOrAlias
     * @param {?} breadcrumb
     * @return {?}
     */
    validateArguments(pathOrAlias, breadcrumb) {
        if (pathOrAlias === null || pathOrAlias === undefined) {
            console.error('Invalid first argument. Please pass a route path or a breadcrumb alias.');
            return false;
        }
        else if (breadcrumb === null || breadcrumb === undefined) {
            console.error('Invalid second argument. Please pass a string or an Object with breadcrumb options.');
            return false;
        }
        return true;
    }
    /**
     * breadcrumb can be passed a label or an options object
     * If passed as a string convert to breadcrumb options object
     * @private
     * @param {?} data
     * @return {?}
     */
    getBreadcrumbOptions(data) {
        let { breadcrumb } = data;
        if (typeof breadcrumb === 'string' || !breadcrumb) {
            breadcrumb = {
                label: breadcrumb
            };
        }
        return breadcrumb;
    }
}
BreadcrumbService.ɵfac = function BreadcrumbService_Factory(t) { return new (t || BreadcrumbService)(ɵngcc0.ɵɵinject(ɵngcc1.ActivatedRoute), ɵngcc0.ɵɵinject(ɵngcc1.Router)); };
BreadcrumbService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BreadcrumbService, factory: BreadcrumbService.ɵfac, providedIn: 'root' });
/** @nocollapse */
BreadcrumbService.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: Router }
];
/** @nocollapse */ BreadcrumbService.ngInjectableDef = ɵɵdefineInjectable({ factory: function BreadcrumbService_Factory() { return new BreadcrumbService(ɵɵinject(ActivatedRoute), ɵɵinject(Router)); }, token: BreadcrumbService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BreadcrumbService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.ActivatedRoute }, { type: ɵngcc1.Router }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BreadcrumbComponent {
    /**
     * @param {?} breadcrumbService
     */
    constructor(breadcrumbService) {
        this.breadcrumbService = breadcrumbService;
        this._separator = '/';
        /**
         * If true, breadcrumb is auto generated even without any mapping label
         * Default label is same as route segment
         */
        this.autoGenerate = true;
        /**
         * By default query params will be preserved with breadcrumbs
         */
        this.preserveQueryParams = true;
        /**
         * custom class provided by consumer to increase specificity
         * This will benefit to override styles that are conflicting
         */
        this.class = '';
    }
    /**
     * separator between breadcrumbs, defaults to '/'.
     * User can customize separator either by passing a String or Template
     *
     * String --> Ex: <xng-breadcrumb separator="-"> </xng-breadcrumb>
     *
     * Template --> Ex: <xng-breadcrumb [separator]="separatorTemplate"> </xng-breadcrumb>
     * <ng-template #separatorTemplate><mat-icon>arrow_right</mat-icon></ng-template>
     * @param {?} value
     * @return {?}
     */
    set separator(value) {
        if (value instanceof TemplateRef) {
            this.separatorTemplate = value;
            this._separator = undefined;
        }
        else {
            this.separatorTemplate = undefined;
            this._separator = value || '/';
        }
    }
    /**
     * @return {?}
     */
    get separator() {
        return this._separator;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscription = this.breadcrumbService.breadcrumbs$.subscribe((/**
         * @param {?} breadcrumbs
         * @return {?}
         */
        breadcrumbs => {
            this.breadcrumbs = breadcrumbs
                .map((/**
             * @param {?} breadcrumb
             * @return {?}
             */
            breadcrumb => {
                if (!this.preserveQueryParams) {
                    breadcrumb.routeLink = breadcrumb.routeLink.split('?')[0];
                }
                return breadcrumb;
            }))
                .filter((/**
             * @param {?} breadcrumb
             * @return {?}
             */
            breadcrumb => {
                // Usually, breadcrumb list can contain a combination of auto generated and user specified labels
                // this filters autogenerated labels in case of "[autoGenerate]: false"
                if (this.autoGenerate) {
                    return true;
                }
                return !breadcrumb.isAutoGeneratedLabel;
            }));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
BreadcrumbComponent.ɵfac = function BreadcrumbComponent_Factory(t) { return new (t || BreadcrumbComponent)(ɵngcc0.ɵɵdirectiveInject(BreadcrumbService)); };
BreadcrumbComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BreadcrumbComponent, selectors: [["xng-breadcrumb"]], contentQueries: function BreadcrumbComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, BreadcrumbItemDirective, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
    } }, inputs: { autoGenerate: "autoGenerate", preserveQueryParams: "preserveQueryParams", class: "class", separator: "separator" }, decls: 3, vars: 2, consts: [["aria-label", "breadcrumb", 1, "xng-breadcrumb-root", 3, "ngClass"], [1, "xng-breadcrumb-list"], [4, "ngFor", "ngForOf"], [1, "xng-breadcrumb-item"], ["class", "xng-breadcrumb-link", 3, "routerLink", "ngClass", "queryParams", "fragment", 4, "ngIf"], ["class", "xng-breadcrumb-trail", 4, "ngIf"], ["class", "xng-breadcrumb-separator", "aria-hidden", "true", "role", "separator", 4, "ngIf"], [1, "xng-breadcrumb-link", 3, "routerLink", "ngClass", "queryParams", "fragment"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], [1, "xng-breadcrumb-trail"], ["aria-hidden", "true", "role", "separator", 1, "xng-breadcrumb-separator"], [4, "ngTemplateOutlet"]], template: function BreadcrumbComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nav", 0);
        ɵngcc0.ɵɵelementStart(1, "ol", 1);
        ɵngcc0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_Template, 5, 3, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.class);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.breadcrumbs);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc2.NgIf, ɵngcc1.RouterLinkWithHref, ɵngcc2.NgTemplateOutlet], styles: [".xng-breadcrumb-root{margin:0;color:rgba(0,0,0,.6)}.xng-breadcrumb-list{display:flex;align-items:center;flex-wrap:wrap;margin:0;padding:0}.xng-breadcrumb-item{list-style:none}.xng-breadcrumb-trail{display:flex;align-items:center;color:rgba(0,0,0,.9)}.xng-breadcrumb-link{display:flex;align-items:center;white-space:nowrap;color:inherit;text-decoration:none;transition:text-decoration .3s;transition:text-decoration .3s,-webkit-text-decoration .3s}.xng-breadcrumb-link:hover{text-decoration:underline}.xng-breadcrumb-link-disabled{pointer-events:none;cursor:disabled}.xng-breadcrumb-separator{display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-left:8px;margin-right:8px}"], encapsulation: 2 });
/** @nocollapse */
BreadcrumbComponent.ctorParameters = () => [
    { type: BreadcrumbService }
];
BreadcrumbComponent.propDecorators = {
    itemTemplate: [{ type: ContentChild, args: [BreadcrumbItemDirective, { static: false, read: TemplateRef },] }],
    autoGenerate: [{ type: Input }],
    preserveQueryParams: [{ type: Input }],
    class: [{ type: Input }],
    separator: [{ type: Input, args: ['separator',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BreadcrumbComponent, [{
        type: Component,
        args: [{
                selector: 'xng-breadcrumb',
                template: "<nav aria-label=\"breadcrumb\" class=\"xng-breadcrumb-root\" [ngClass]=\"class\">\n  <ol class=\"xng-breadcrumb-list\">\n    <ng-container *ngFor=\"let breadcrumb of breadcrumbs; last as isLast; first as isFirst\">\n      <li class=\"xng-breadcrumb-item\">\n        <a\n          *ngIf=\"!isLast\"\n          [routerLink]=\"[breadcrumb.routeLink]\"\n          class=\"xng-breadcrumb-link\"\n          [ngClass]=\"{ 'xng-breadcrumb-link-disabled': breadcrumb.disable }\"\n          [attr.aria-disabled]=\"breadcrumb.disable\"\n          [queryParams]=\"breadcrumb.queryParams\"\n          [fragment]=\"breadcrumb.fragment\"\n        >\n          <ng-container\n            *ngTemplateOutlet=\"itemTemplate; context: { $implicit: breadcrumb.label, info: breadcrumb.info, last: isLast, first: isFirst }\"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{ breadcrumb.label }}</ng-container>\n        </a>\n\n        <label *ngIf=\"isLast\" class=\"xng-breadcrumb-trail\">\n          <ng-container\n            *ngTemplateOutlet=\"itemTemplate; context: { $implicit: breadcrumb.label, info: breadcrumb.info, last: isLast, first: isFirst }\"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{ breadcrumb.label }}</ng-container>\n        </label>\n      </li>\n\n      <li *ngIf=\"!isLast\" class=\"xng-breadcrumb-separator\" aria-hidden=\"true\" role=\"separator\">\n        <ng-container *ngTemplateOutlet=\"separatorTemplate\"></ng-container>\n        <ng-container *ngIf=\"!separatorTemplate\">{{ separator }}</ng-container>\n      </li>\n    </ng-container>\n  </ol>\n</nav>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".xng-breadcrumb-root{margin:0;color:rgba(0,0,0,.6)}.xng-breadcrumb-list{display:flex;align-items:center;flex-wrap:wrap;margin:0;padding:0}.xng-breadcrumb-item{list-style:none}.xng-breadcrumb-trail{display:flex;align-items:center;color:rgba(0,0,0,.9)}.xng-breadcrumb-link{display:flex;align-items:center;white-space:nowrap;color:inherit;text-decoration:none;transition:text-decoration .3s;transition:text-decoration .3s,-webkit-text-decoration .3s}.xng-breadcrumb-link:hover{text-decoration:underline}.xng-breadcrumb-link-disabled{pointer-events:none;cursor:disabled}.xng-breadcrumb-separator{display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-left:8px;margin-right:8px}"]
            }]
    }], function () { return [{ type: BreadcrumbService }]; }, { autoGenerate: [{
            type: Input
        }], preserveQueryParams: [{
            type: Input
        }], class: [{
            type: Input
        }], separator: [{
            type: Input,
            args: ['separator']
        }], itemTemplate: [{
            type: ContentChild,
            args: [BreadcrumbItemDirective, { static: false, read: TemplateRef }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BreadcrumbModule {
}
BreadcrumbModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BreadcrumbModule });
BreadcrumbModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BreadcrumbModule_Factory(t) { return new (t || BreadcrumbModule)(); }, imports: [[CommonModule, RouterModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BreadcrumbModule, { declarations: function () { return [BreadcrumbComponent,
        BreadcrumbItemDirective]; }, imports: function () { return [CommonModule, RouterModule]; }, exports: function () { return [BreadcrumbComponent,
        BreadcrumbItemDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BreadcrumbModule, [{
        type: NgModule,
        args: [{
                declarations: [BreadcrumbComponent, BreadcrumbItemDirective],
                imports: [CommonModule, RouterModule],
                exports: [BreadcrumbComponent, BreadcrumbItemDirective]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BreadcrumbItemDirective, BreadcrumbComponent, BreadcrumbModule, BreadcrumbService };

//# sourceMappingURL=xng-breadcrumb.js.map