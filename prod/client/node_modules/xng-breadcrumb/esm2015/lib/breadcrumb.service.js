/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { ActivatedRoute, NavigationEnd, Router } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged, filter } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
export class BreadcrumbService {
    /**
     * @param {?} activatedRoute
     * @param {?} router
     */
    constructor(activatedRoute, router) {
        this.activatedRoute = activatedRoute;
        this.router = router;
        this.baseHref = '/';
        /**
         * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.
         * Breadcrumbs can be set from anywhere (component, service) in the app.
         * On every breadcrumb update check this store and use the info if available.
         */
        this.dynamicBreadcrumbStore = [];
        /**
         * breadcrumbList for the current route
         * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected
         * If effected, update the change and emit a new stream
         */
        this.currentBreadcrumbs = [];
        this.previousBreadcrumbs = [];
        /**
         * Breadcrumbs observable to be subscribed by BreadcrumbComponent
         * Emits on every route change OR dynamic update of breadcrumb
         */
        this.breadcrumbs = new BehaviorSubject([]);
        this.breadcrumbs$ = this.breadcrumbs.asObservable();
        this.pathParamPrefix = ':';
        this.pathParamRegexIdentifier = '/:[^/]+';
        this.pathParamRegexReplacer = '/[^/]+';
        this.setBaseBreadcrumb();
        this.detectRouteChanges();
    }
    /**
     * Update breadcrumb label or options for -
     *
     * route (complete route path). route can be passed the same way you define angular routes
     * 1) update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')
     * 2) change visibility Ex: set('/mentor/:id/edit', { skip: true })
     * 3) add info Ex: set('/mentor/:id/edit', { info: { icon: 'edit', iconColor: 'blue' } })
     * ------------------------ OR -------------------------
     *
     * alias (prefixed with '\@'). breadcrumb alias is unique for a route
     * 1) update label Ex: set('\@mentor', 'Enabler')
     * 2) change visibility Ex: set('\@mentorEdit', { skip: true })
     * 3) add info Ex: set('\@mentorEdit', { info: { icon: 'edit', iconColor: 'blue' } })
     * @param {?} pathOrAlias
     * @param {?} breadcrumb
     * @return {?}
     */
    set(pathOrAlias, breadcrumb) {
        if (!this.validateArguments(pathOrAlias, breadcrumb)) {
            return;
        }
        if (typeof breadcrumb === 'string') {
            breadcrumb = {
                label: breadcrumb
            };
        }
        if (pathOrAlias.startsWith('@')) {
            this.updateStore(Object.assign({}, breadcrumb, { alias: pathOrAlias.slice(1) }));
        }
        else {
            /** @type {?} */
            const breadcrumbExtraProps = this.buildRouteRegExp(pathOrAlias);
            this.updateStore(Object.assign({}, breadcrumb, breadcrumbExtraProps));
        }
    }
    /**
     * @private
     * @return {?}
     */
    setBaseBreadcrumb() {
        /** @type {?} */
        const baseConfig = this.router.config.find((/**
         * @param {?} pathConfig
         * @return {?}
         */
        pathConfig => pathConfig.path === ''));
        if (baseConfig && baseConfig.data) {
            let { label, alias, skip = false, info, disable = false } = this.getBreadcrumbOptions(baseConfig.data);
            /** @type {?} */
            let isAutoGeneratedLabel = false;
            if (typeof label !== 'string' && !label) {
                label = '';
                isAutoGeneratedLabel = true;
            }
            this.baseBreadcrumb = {
                label,
                alias,
                skip,
                disable,
                info,
                routeLink: this.baseHref,
                isAutoGeneratedLabel
            };
        }
    }
    /**
     * Whenever route changes build breadcrumb list again
     * @private
     * @return {?}
     */
    detectRouteChanges() {
        this.router.events
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event instanceof NavigationEnd)), distinctUntilChanged())
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this.previousBreadcrumbs = this.currentBreadcrumbs;
            this.currentBreadcrumbs = this.baseBreadcrumb ? [this.baseBreadcrumb] : [];
            this.prepareBreadcrumbList(this.activatedRoute.root, this.baseHref);
        }));
    }
    /**
     * @private
     * @param {?} activatedRoute
     * @param {?} routeLinkPrefix
     * @return {?}
     */
    prepareBreadcrumbList(activatedRoute, routeLinkPrefix) {
        if (activatedRoute.routeConfig && activatedRoute.routeConfig.path) {
            /** @type {?} */
            const breadcrumbItem = this.prepareBreadcrumbItem(activatedRoute, routeLinkPrefix);
            this.currentBreadcrumbs.push(breadcrumbItem);
            if (activatedRoute.firstChild) {
                return this.prepareBreadcrumbList(activatedRoute.firstChild, breadcrumbItem.routeLink + '/');
            }
        }
        else if (activatedRoute.firstChild) {
            return this.prepareBreadcrumbList(activatedRoute.firstChild, routeLinkPrefix);
        }
        // remove breadcrumb items that needs to be hidden or don't have a label
        /** @type {?} */
        const breadcrumbsToShow = this.currentBreadcrumbs.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => !item.skip));
        this.breadcrumbs.next(breadcrumbsToShow);
    }
    /**
     * @private
     * @param {?} activatedRoute
     * @param {?} routeLinkPrefix
     * @return {?}
     */
    prepareBreadcrumbItem(activatedRoute, routeLinkPrefix) {
        const { path, breadcrumb } = this.parseRouteData(activatedRoute.routeConfig);
        // in case of path param get the resolved for param
        /** @type {?} */
        const resolvedPath = this.resolvePathParam(path, activatedRoute);
        /** @type {?} */
        const routeLink = `${routeLinkPrefix}${resolvedPath}`;
        let { label, alias, skip, disable, info } = this.getFromStore(breadcrumb.alias, routeLink);
        /** @type {?} */
        let isAutoGeneratedLabel = false;
        if (typeof label !== 'string') {
            if (typeof breadcrumb.label === 'string') {
                label = breadcrumb.label;
            }
            else {
                label = resolvedPath;
                isAutoGeneratedLabel = true;
            }
        }
        return Object.assign({ label, alias: alias || breadcrumb.alias, skip: skip || breadcrumb.skip, disable: disable || breadcrumb.disable, info: info || breadcrumb.info, routeLink,
            isAutoGeneratedLabel }, this.resolveQueryParam(routeLink, activatedRoute));
    }
    /**
     * For a specific route, breadcrumb can be defined either on parent data OR it's child(which has empty path) data
     * When both are defined, child takes precedence
     *
     * Ex: Below we are setting breadcrumb on both parent and child.
     * So, child takes precedence and "Defined On Child" is displayed for the route 'home'
     * { path: 'home', loadChildren: './home/home.module#HomeModule' , data: {breadcrumb: "Defined On Module"}}
     *                                                AND
     * children: [
     *   { path: '', component: ShowUserComponent, data: {breadcrumb: "Defined On Child" }
     * ]
     * @private
     * @param {?} routeConfig
     * @return {?}
     */
    parseRouteData(routeConfig) {
        const { path, data = {} } = routeConfig;
        /** @type {?} */
        const breadcrumb = this.mergeWithBaseChildData(routeConfig, Object.assign({}, data));
        return { path, breadcrumb };
    }
    /**
     * @private
     * @param {?} breadcrumbAlias
     * @param {?} routeLink
     * @return {?}
     */
    getFromStore(breadcrumbAlias, routeLink) {
        /** @type {?} */
        let matchingItem;
        if (breadcrumbAlias) {
            matchingItem = this.dynamicBreadcrumbStore.find((/**
             * @param {?} item
             * @return {?}
             */
            item => item.alias === breadcrumbAlias));
        }
        if (!matchingItem && routeLink) {
            matchingItem = this.dynamicBreadcrumbStore.find((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return (item.routeLink && item.routeLink === routeLink) || (item.routeRegex && new RegExp(item.routeRegex).test(routeLink + '/'));
            }));
        }
        return matchingItem || {};
    }
    /**
     * To update breadcrumb label for a route with path param, we need regex that matches route.
     * Instead of user providing regex, we help in preparing regex dynamically
     *
     * Ex: route declaration - path: '/mentor/:id'
     * breadcrumbService.set('/mentor/:id', 'Uday');
     * '/mentor/2' OR 'mentor/ada' we should use 'Uday' as label
     *
     * regex string is built, if route has path params(contains with ':')
     * @private
     * @param {?} path
     * @return {?}
     */
    buildRouteRegExp(path) {
        // ensure leading slash is provided in the path
        if (!path.startsWith('/')) {
            path = '/' + path;
        }
        if (path.includes(this.pathParamPrefix)) {
            // replace mathing path param with a regex
            // '/mentor/:id' becomes '/mentor/[^/]', which further will be matched in updateStore
            /** @type {?} */
            const routeRegex = path.replace(new RegExp(this.pathParamRegexIdentifier, 'g'), this.pathParamRegexReplacer);
            return { routeRegex };
        }
        else {
            return { routeLink: path };
        }
    }
    /**
     * Update current breadcrumb definition and emit a new stream of breadcrumbs
     * Also update the store to reuse dynamic declarations
     * @private
     * @param {?} breadcrumb
     * @return {?}
     */
    updateStore(breadcrumb) {
        const { breadcrumbItemIndex, storeItemIndex } = this.getBreadcrumbIndexes(breadcrumb);
        // if breadcrumb is present in current breadcrumbs update it and emit new stream
        if (breadcrumbItemIndex > -1) {
            this.currentBreadcrumbs[breadcrumbItemIndex] = Object.assign({}, this.currentBreadcrumbs[breadcrumbItemIndex], breadcrumb);
            /** @type {?} */
            const breadcrumbsToShow = this.currentBreadcrumbs.filter((/**
             * @param {?} item
             * @return {?}
             */
            item => !item.skip));
            this.breadcrumbs.next([...breadcrumbsToShow]);
        }
        // If the store already has this route definition update it, else add
        if (storeItemIndex > -1) {
            this.dynamicBreadcrumbStore[storeItemIndex] = Object.assign({}, this.dynamicBreadcrumbStore[storeItemIndex], breadcrumb);
        }
        else {
            this.dynamicBreadcrumbStore.push(breadcrumb);
        }
    }
    /**
     * @private
     * @param {?} breadcrumb
     * @return {?}
     */
    getBreadcrumbIndexes(breadcrumb) {
        const { alias, routeLink, routeRegex } = breadcrumb;
        /** @type {?} */
        let indexMap = {};
        // identify macthing breadcrumb and store item
        if (alias) {
            indexMap = this.getBreadcrumbIndexesByType('alias', alias);
        }
        else if (routeLink) {
            indexMap = this.getBreadcrumbIndexesByType('routeLink', routeLink);
        }
        else if (routeRegex) {
            indexMap = this.getBreadcrumbIndexesByType('routeRegex', routeRegex);
        }
        return indexMap;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    getBreadcrumbIndexesByType(key, value) {
        /** @type {?} */
        let breadcrumbItemIndex;
        if (key !== 'routeRegex') {
            breadcrumbItemIndex = this.currentBreadcrumbs.findIndex((/**
             * @param {?} item
             * @return {?}
             */
            item => value === item[key]));
        }
        else {
            breadcrumbItemIndex = this.currentBreadcrumbs.findIndex((/**
             * @param {?} item
             * @return {?}
             */
            item => new RegExp(value).test(item.routeLink)));
        }
        /** @type {?} */
        const storeItemIndex = this.dynamicBreadcrumbStore.findIndex((/**
         * @param {?} item
         * @return {?}
         */
        item => value === item[key]));
        return { breadcrumbItemIndex, storeItemIndex };
    }
    /**
     * @private
     * @param {?} path
     * @param {?} activatedRoute
     * @return {?}
     */
    resolvePathParam(path, activatedRoute) {
        // if the path segment is a route param, read the param value from url
        if (path.startsWith(this.pathParamPrefix)) {
            return activatedRoute.snapshot.params[path.slice(1)];
        }
        return path;
    }
    /**
     * @private
     * @param {?} routeLink
     * @param {?} activatedRoute
     * @return {?}
     */
    resolveQueryParam(routeLink, activatedRoute) {
        /** @type {?} */
        const previousBreadcrumb = this.previousBreadcrumbs.find((/**
         * @param {?} item
         * @return {?}
         */
        item => item.routeLink === routeLink)) || {};
        const { queryParams, fragment } = activatedRoute.snapshot;
        return {
            queryParams: Object.keys(queryParams).length > 0 ? Object.assign({}, queryParams) : previousBreadcrumb.queryParams,
            fragment: fragment || previousBreadcrumb.fragment
        };
    }
    /**
     * get empty children of a module or Component. Empty child is the one with path: ''
     * When parent and it's children (that has empty route path) define data
     * merge them both with child taking precedence
     * @private
     * @param {?} routeConfig
     * @param {?} data
     * @return {?}
     */
    mergeWithBaseChildData(routeConfig, data) {
        if (!routeConfig) {
            return this.getBreadcrumbOptions(data);
        }
        /** @type {?} */
        let baseChild;
        if (routeConfig.loadChildren) {
            // To handle a module with empty child route
            baseChild = routeConfig._loadedConfig.routes.find((/**
             * @param {?} route
             * @return {?}
             */
            route => route.path === ''));
        }
        else if (routeConfig.children) {
            // To handle a component with empty child route
            baseChild = routeConfig.children.find((/**
             * @param {?} route
             * @return {?}
             */
            route => route.path === ''));
        }
        return baseChild && baseChild.data
            ? this.mergeWithBaseChildData(baseChild, Object.assign({}, this.getBreadcrumbOptions(data), this.getBreadcrumbOptions(baseChild.data)))
            : this.getBreadcrumbOptions(data);
    }
    /**
     * @private
     * @param {?} pathOrAlias
     * @param {?} breadcrumb
     * @return {?}
     */
    validateArguments(pathOrAlias, breadcrumb) {
        if (pathOrAlias === null || pathOrAlias === undefined) {
            console.error('Invalid first argument. Please pass a route path or a breadcrumb alias.');
            return false;
        }
        else if (breadcrumb === null || breadcrumb === undefined) {
            console.error('Invalid second argument. Please pass a string or an Object with breadcrumb options.');
            return false;
        }
        return true;
    }
    /**
     * breadcrumb can be passed a label or an options object
     * If passed as a string convert to breadcrumb options object
     * @private
     * @param {?} data
     * @return {?}
     */
    getBreadcrumbOptions(data) {
        let { breadcrumb } = data;
        if (typeof breadcrumb === 'string' || !breadcrumb) {
            breadcrumb = {
                label: breadcrumb
            };
        }
        return breadcrumb;
    }
}
BreadcrumbService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BreadcrumbService.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: Router }
];
/** @nocollapse */ BreadcrumbService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function BreadcrumbService_Factory() { return new BreadcrumbService(i0.ɵɵinject(i1.ActivatedRoute), i0.ɵɵinject(i1.Router)); }, token: BreadcrumbService, providedIn: "root" });
if (false) {
    /**
     * breadcrumb label for base OR root path. Usually, this can be set as 'Home'
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.baseBreadcrumb;
    /**
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.baseHref;
    /**
     * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.
     * Breadcrumbs can be set from anywhere (component, service) in the app.
     * On every breadcrumb update check this store and use the info if available.
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.dynamicBreadcrumbStore;
    /**
     * breadcrumbList for the current route
     * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected
     * If effected, update the change and emit a new stream
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.currentBreadcrumbs;
    /**
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.previousBreadcrumbs;
    /**
     * Breadcrumbs observable to be subscribed by BreadcrumbComponent
     * Emits on every route change OR dynamic update of breadcrumb
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.breadcrumbs;
    /** @type {?} */
    BreadcrumbService.prototype.breadcrumbs$;
    /**
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.pathParamPrefix;
    /**
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.pathParamRegexIdentifier;
    /**
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.pathParamRegexReplacer;
    /**
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.activatedRoute;
    /**
     * @type {?}
     * @private
     */
    BreadcrumbService.prototype.router;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWRjcnVtYi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8veG5nLWJyZWFkY3J1bWIvIiwic291cmNlcyI6WyJsaWIvYnJlYWRjcnVtYi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkMsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFNOUQsTUFBTSxPQUFPLGlCQUFpQjs7Ozs7SUFrQzVCLFlBQW9CLGNBQThCLEVBQVUsTUFBYztRQUF0RCxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBNUJsRSxhQUFRLEdBQUcsR0FBRyxDQUFDOzs7Ozs7UUFPZiwyQkFBc0IsR0FBaUIsRUFBRSxDQUFDOzs7Ozs7UUFPMUMsdUJBQWtCLEdBQWlCLEVBQUUsQ0FBQztRQUN0Qyx3QkFBbUIsR0FBaUIsRUFBRSxDQUFDOzs7OztRQU12QyxnQkFBVyxHQUFHLElBQUksZUFBZSxDQUFlLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELGlCQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUU5QyxvQkFBZSxHQUFHLEdBQUcsQ0FBQztRQUN0Qiw2QkFBd0IsR0FBRyxTQUFTLENBQUM7UUFDckMsMkJBQXNCLEdBQUcsUUFBUSxDQUFDO1FBR3hDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQzVCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdCRCxHQUFHLENBQUMsV0FBbUIsRUFBRSxVQUErQjtRQUN0RCxJ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QUFDOzs7Ozs7OztJQU1PLG9CQUFvQixDQUFDLElBQUk7WUFDM0IsRUFBRSxVQUFVLEVBQUUsR0FBRyxJQUFJO1FBQ3pCLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2pELFVBQVUsR0FBRztnQkFDWCxLQUFLLEVBQUUsVUFBVTthQUNsQixDQUFDO1NBQ0g7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDOzs7WUFuVkYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7O1lBUFEsY0FBYztZQUFpQixNQUFNOzs7Ozs7Ozs7SUFZNUMsMkNBQW1DOzs7OztJQUVuQyxxQ0FBdUI7Ozs7Ozs7O0lBT3ZCLG1EQUFrRDs7Ozs7Ozs7SUFPbEQsK0NBQThDOzs7OztJQUM5QyxnREFBK0M7Ozs7Ozs7SUFNL0Msd0NBQTREOztJQUM1RCx5Q0FBc0Q7Ozs7O0lBRXRELDRDQUE4Qjs7Ozs7SUFDOUIscURBQTZDOzs7OztJQUM3QyxtREFBMEM7Ozs7O0lBRTlCLDJDQUFzQzs7Ozs7SUFBRSxtQ0FBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSwgTmF2aWdhdGlvbkVuZCwgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEJyZWFkY3J1bWIgfSBmcm9tICcuL2JyZWFkY3J1bWInO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBCcmVhZGNydW1iU2VydmljZSB7XG4gIC8qKlxuICAgKiBicmVhZGNydW1iIGxhYmVsIGZvciBiYXNlIE9SIHJvb3QgcGF0aC4gVXN1YWxseSwgdGhpcyBjYW4gYmUgc2V0IGFzICdIb21lJ1xuICAgKi9cbiAgcHJpdmF0ZSBiYXNlQnJlYWRjcnVtYjogQnJlYWRjcnVtYjtcblxuICBwcml2YXRlIGJhc2VIcmVmID0gJy8nO1xuXG4gIC8qKlxuICAgKiBkeW5hbWljQnJlYWRjcnVtYlN0b3JlIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGR5bmFtaWNhbGx5IHVwZGF0ZWQgYnJlYWRjcnVtYnMuXG4gICAqIEJyZWFkY3J1bWJzIGNhbiBiZSBzZXQgZnJvbSBhbnl3aGVyZSAoY29tcG9uZW50LCBzZXJ2aWNlKSBpbiB0aGUgYXBwLlxuICAgKiBPbiBldmVyeSBicmVhZGNydW1iIHVwZGF0ZSBjaGVjayB0aGlzIHN0b3JlIGFuZCB1c2UgdGhlIGluZm8gaWYgYXZhaWxhYmxlLlxuICAgKi9cbiAgcHJpdmF0ZSBkeW5hbWljQnJlYWRjcnVtYlN0b3JlOiBCcmVhZGNydW1iW10gPSBbXTtcblxuICAvKipcbiAgICogYnJlYWRjcnVtYkxpc3QgZm9yIHRoZSBjdXJyZW50IHJvdXRlXG4gICAqIFdoZW4gYnJlYWRjcnVtYiBpbmZvIGlzIGNoYW5nZWQgZHluYW1pY2FsbHksIGNoZWNrIGlmIHRoZSBjdXJyZW50QnJlYWRjcnVtYnMgaXMgZWZmZWN0ZWRcbiAgICogSWYgZWZmZWN0ZWQsIHVwZGF0ZSB0aGUgY2hhbmdlIGFuZCBlbWl0IGEgbmV3IHN0cmVhbVxuICAgKi9cbiAgcHJpdmF0ZSBjdXJyZW50QnJlYWRjcnVtYnM6IEJyZWFkY3J1bWJbXSA9IFtdO1xuICBwcml2YXRlIHByZXZpb3VzQnJlYWRjcnVtYnM6IEJyZWFkY3J1bWJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBCcmVhZGNydW1icyBvYnNlcnZhYmxlIHRvIGJlIHN1YnNjcmliZWQgYnkgQnJlYWRjcnVtYkNvbXBvbmVudFxuICAgKiBFbWl0cyBvbiBldmVyeSByb3V0ZSBjaGFuZ2UgT1IgZHluYW1pYyB1cGRhdGUgb2YgYnJlYWRjcnVtYlxuICAgKi9cbiAgcHJpdmF0ZSBicmVhZGNydW1icyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8QnJlYWRjcnVtYltdPihbXSk7XG4gIHB1YmxpYyBicmVhZGNydW1icyQgPSB0aGlzLmJyZWFkY3J1bWJzLmFzT2JzZXJ2YWJsZSgpO1xuXG4gIHByaXZhdGUgcGF0aFBhcmFtUHJlZml4ID0gJzonO1xuICBwcml2YXRlIHBhdGhQYXJhbVJlZ2V4SWRlbnRpZmllciA9ICcvOlteL10rJztcbiAgcHJpdmF0ZSBwYXRoUGFyYW1SZWdleFJlcGxhY2VyID0gJy9bXi9dKyc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhY3RpdmF0ZWRSb3V0ZTogQWN0aXZhdGVkUm91dGUsIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIpIHtcbiAgICB0aGlzLnNldEJhc2VCcmVhZGNydW1iKCk7XG4gICAgdGhpcy5kZXRlY3RSb3V0ZUNoYW5nZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYnJlYWRjcnVtYiBsYWJlbCBvciBvcHRpb25zIGZvciAtXG4gICAqXG4gICAqIHJvdXRlIChjb21wbGV0ZSByb3V0ZSBwYXRoKS4gcm91dGUgY2FuIGJlIHBhc3NlZCB0aGUgc2FtZSB3YXkgeW91IGRlZmluZSBhbmd1bGFyIHJvdXRlc1xuICAgKiAxKSB1cGRhdGUgbGFiZWwgRXg6IHNldCgnL21lbnRvcicsICdNZW50b3InKSwgc2V0KCcvbWVudG9yLzppZCcsICdNZW50b3IgRGV0YWlscycpXG4gICAqIDIpIGNoYW5nZSB2aXNpYmlsaXR5IEV4OiBzZXQoJy9tZW50b3IvOmlkL2VkaXQnLCB7IHNraXA6IHRydWUgfSlcbiAgICogMykgYWRkIGluZm8gRXg6IHNldCgnL21lbnRvci86aWQvZWRpdCcsIHsgaW5mbzogeyBpY29uOiAnZWRpdCcsIGljb25Db2xvcjogJ2JsdWUnIH0gfSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE9SIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogYWxpYXMgKHByZWZpeGVkIHdpdGggJ0AnKS4gYnJlYWRjcnVtYiBhbGlhcyBpcyB1bmlxdWUgZm9yIGEgcm91dGVcbiAgICogMSkgdXBkYXRlIGxhYmVsIEV4OiBzZXQoJ0BtZW50b3InLCAnRW5hYmxlcicpXG4gICAqIDIpIGNoYW5nZSB2aXNpYmlsaXR5IEV4OiBzZXQoJ0BtZW50b3JFZGl0JywgeyBza2lwOiB0cnVlIH0pXG4gICAqIDMpIGFkZCBpbmZvIEV4OiBzZXQoJ0BtZW50b3JFZGl0JywgeyBpbmZvOiB7IGljb246ICdlZGl0JywgaWNvbkNvbG9yOiAnYmx1ZScgfSB9KVxuICAgKi9cbiAgc2V0KHBhdGhPckFsaWFzOiBzdHJpbmcsIGJyZWFkY3J1bWI6IHN0cmluZyB8IEJyZWFkY3J1bWIpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGVBcmd1bWVudHMocGF0aE9yQWxpYXMsIGJyZWFkY3J1bWIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBicmVhZGNydW1iID09PSAnc3RyaW5nJykge1xuICAgICAgYnJlYWRjcnVtYiA9IHtcbiAgICAgICAgbGFiZWw6IGJyZWFkY3J1bWJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHBhdGhPckFsaWFzLnN0YXJ0c1dpdGgoJ0AnKSkge1xuICAgICAgdGhpcy51cGRhdGVTdG9yZSh7IC4uLmJyZWFkY3J1bWIsIGFsaWFzOiBwYXRoT3JBbGlhcy5zbGljZSgxKSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnJlYWRjcnVtYkV4dHJhUHJvcHMgPSB0aGlzLmJ1aWxkUm91dGVSZWdFeHAocGF0aE9yQWxpYXMpO1xuICAgICAgdGhpcy51cGRhdGVTdG9yZSh7IC4uLmJyZWFkY3J1bWIsIC4uLmJyZWFkY3J1bWJFeHRyYVByb3BzIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0QmFzZUJyZWFkY3J1bWIoKSB7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHRoaXMucm91dGVyLmNvbmZpZy5maW5kKHBhdGhDb25maWcgPT4gcGF0aENvbmZpZy5wYXRoID09PSAnJyk7XG4gICAgaWYgKGJhc2VDb25maWcgJiYgYmFzZUNvbmZpZy5kYXRhKSB7XG4gICAgICBsZXQgeyBsYWJlbCwgYWxpYXMsIHNraXAgPSBmYWxzZSwgaW5mbywgZGlzYWJsZSA9IGZhbHNlIH0gPSB0aGlzLmdldEJyZWFkY3J1bWJPcHRpb25zKGJhc2VDb25maWcuZGF0YSk7XG5cbiAgICAgIGxldCBpc0F1dG9HZW5lcmF0ZWRMYWJlbCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ3N0cmluZycgJiYgIWxhYmVsKSB7XG4gICAgICAgIGxhYmVsID0gJyc7XG4gICAgICAgIGlzQXV0b0dlbmVyYXRlZExhYmVsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iYXNlQnJlYWRjcnVtYiA9IHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGFsaWFzLFxuICAgICAgICBza2lwLFxuICAgICAgICBkaXNhYmxlLFxuICAgICAgICBpbmZvLFxuICAgICAgICByb3V0ZUxpbms6IHRoaXMuYmFzZUhyZWYsXG4gICAgICAgIGlzQXV0b0dlbmVyYXRlZExhYmVsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuZXZlciByb3V0ZSBjaGFuZ2VzIGJ1aWxkIGJyZWFkY3J1bWIgbGlzdCBhZ2FpblxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RSb3V0ZUNoYW5nZXMoKSB7XG4gICAgdGhpcy5yb3V0ZXIuZXZlbnRzXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByZXZpb3VzQnJlYWRjcnVtYnMgPSB0aGlzLmN1cnJlbnRCcmVhZGNydW1icztcblxuICAgICAgICB0aGlzLmN1cnJlbnRCcmVhZGNydW1icyA9IHRoaXMuYmFzZUJyZWFkY3J1bWIgPyBbdGhpcy5iYXNlQnJlYWRjcnVtYl0gOiBbXTtcbiAgICAgICAgdGhpcy5wcmVwYXJlQnJlYWRjcnVtYkxpc3QodGhpcy5hY3RpdmF0ZWRSb3V0ZS5yb290LCB0aGlzLmJhc2VIcmVmKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVwYXJlQnJlYWRjcnVtYkxpc3QoYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlLCByb3V0ZUxpbmtQcmVmaXg6IHN0cmluZyk6IEJyZWFkY3J1bWJbXSB7XG4gICAgaWYgKGFjdGl2YXRlZFJvdXRlLnJvdXRlQ29uZmlnICYmIGFjdGl2YXRlZFJvdXRlLnJvdXRlQ29uZmlnLnBhdGgpIHtcbiAgICAgIGNvbnN0IGJyZWFkY3J1bWJJdGVtID0gdGhpcy5wcmVwYXJlQnJlYWRjcnVtYkl0ZW0oYWN0aXZhdGVkUm91dGUsIHJvdXRlTGlua1ByZWZpeCk7XG4gICAgICB0aGlzLmN1cnJlbnRCcmVhZGNydW1icy5wdXNoKGJyZWFkY3J1bWJJdGVtKTtcblxuICAgICAgaWYgKGFjdGl2YXRlZFJvdXRlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZUJyZWFkY3J1bWJMaXN0KGFjdGl2YXRlZFJvdXRlLmZpcnN0Q2hpbGQsIGJyZWFkY3J1bWJJdGVtLnJvdXRlTGluayArICcvJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3RpdmF0ZWRSb3V0ZS5maXJzdENoaWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVwYXJlQnJlYWRjcnVtYkxpc3QoYWN0aXZhdGVkUm91dGUuZmlyc3RDaGlsZCwgcm91dGVMaW5rUHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGJyZWFkY3J1bWIgaXRlbXMgdGhhdCBuZWVkcyB0byBiZSBoaWRkZW4gb3IgZG9uJ3QgaGF2ZSBhIGxhYmVsXG4gICAgY29uc3QgYnJlYWRjcnVtYnNUb1Nob3cgPSB0aGlzLmN1cnJlbnRCcmVhZGNydW1icy5maWx0ZXIoaXRlbSA9PiAhaXRlbS5za2lwKTtcblxuICAgIHRoaXMuYnJlYWRjcnVtYnMubmV4dChicmVhZGNydW1ic1RvU2hvdyk7XG4gIH1cblxuICBwcml2YXRlIHByZXBhcmVCcmVhZGNydW1iSXRlbShhY3RpdmF0ZWRSb3V0ZTogQWN0aXZhdGVkUm91dGUsIHJvdXRlTGlua1ByZWZpeDogc3RyaW5nKTogQnJlYWRjcnVtYiB7XG4gICAgY29uc3QgeyBwYXRoLCBicmVhZGNydW1iIH0gPSB0aGlzLnBhcnNlUm91dGVEYXRhKGFjdGl2YXRlZFJvdXRlLnJvdXRlQ29uZmlnKTtcblxuICAgIC8vIGluIGNhc2Ugb2YgcGF0aCBwYXJhbSBnZXQgdGhlIHJlc29sdmVkIGZvciBwYXJhbVxuICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHRoaXMucmVzb2x2ZVBhdGhQYXJhbShwYXRoLCBhY3RpdmF0ZWRSb3V0ZSk7XG4gICAgY29uc3Qgcm91dGVMaW5rID0gYCR7cm91dGVMaW5rUHJlZml4fSR7cmVzb2x2ZWRQYXRofWA7XG5cbiAgICBsZXQgeyBsYWJlbCwgYWxpYXMsIHNraXAsIGRpc2FibGUsIGluZm8gfSA9IHRoaXMuZ2V0RnJvbVN0b3JlKGJyZWFkY3J1bWIuYWxpYXMsIHJvdXRlTGluayk7XG4gICAgbGV0IGlzQXV0b0dlbmVyYXRlZExhYmVsID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBicmVhZGNydW1iLmxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgICBsYWJlbCA9IGJyZWFkY3J1bWIubGFiZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbCA9IHJlc29sdmVkUGF0aDtcbiAgICAgICAgaXNBdXRvR2VuZXJhdGVkTGFiZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbCxcbiAgICAgIGFsaWFzOiBhbGlhcyB8fCBicmVhZGNydW1iLmFsaWFzLFxuICAgICAgc2tpcDogc2tpcCB8fCBicmVhZGNydW1iLnNraXAsXG4gICAgICBkaXNhYmxlOiBkaXNhYmxlIHx8IGJyZWFkY3J1bWIuZGlzYWJsZSxcbiAgICAgIGluZm86IGluZm8gfHwgYnJlYWRjcnVtYi5pbmZvLFxuICAgICAgcm91dGVMaW5rLFxuICAgICAgaXNBdXRvR2VuZXJhdGVkTGFiZWwsXG4gICAgICAuLi50aGlzLnJlc29sdmVRdWVyeVBhcmFtKHJvdXRlTGluaywgYWN0aXZhdGVkUm91dGUpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBzcGVjaWZpYyByb3V0ZSwgYnJlYWRjcnVtYiBjYW4gYmUgZGVmaW5lZCBlaXRoZXIgb24gcGFyZW50IGRhdGEgT1IgaXQncyBjaGlsZCh3aGljaCBoYXMgZW1wdHkgcGF0aCkgZGF0YVxuICAgKiBXaGVuIGJvdGggYXJlIGRlZmluZWQsIGNoaWxkIHRha2VzIHByZWNlZGVuY2VcbiAgICpcbiAgICogRXg6IEJlbG93IHdlIGFyZSBzZXR0aW5nIGJyZWFkY3J1bWIgb24gYm90aCBwYXJlbnQgYW5kIGNoaWxkLlxuICAgKiBTbywgY2hpbGQgdGFrZXMgcHJlY2VkZW5jZSBhbmQgXCJEZWZpbmVkIE9uIENoaWxkXCIgaXMgZGlzcGxheWVkIGZvciB0aGUgcm91dGUgJ2hvbWUnXG4gICAqIHsgcGF0aDogJ2hvbWUnLCBsb2FkQ2hpbGRyZW46ICcuL2hvbWUvaG9tZS5tb2R1bGUjSG9tZU1vZHVsZScgLCBkYXRhOiB7YnJlYWRjcnVtYjogXCJEZWZpbmVkIE9uIE1vZHVsZVwifX1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBTkRcbiAgICogY2hpbGRyZW46IFtcbiAgICogICB7IHBhdGg6ICcnLCBjb21wb25lbnQ6IFNob3dVc2VyQ29tcG9uZW50LCBkYXRhOiB7YnJlYWRjcnVtYjogXCJEZWZpbmVkIE9uIENoaWxkXCIgfVxuICAgKiBdXG4gICAqL1xuICBwcml2YXRlIHBhcnNlUm91dGVEYXRhKHJvdXRlQ29uZmlnKSB7XG4gICAgY29uc3QgeyBwYXRoLCBkYXRhID0ge30gfSA9IHJvdXRlQ29uZmlnO1xuICAgIGNvbnN0IGJyZWFkY3J1bWIgPSB0aGlzLm1lcmdlV2l0aEJhc2VDaGlsZERhdGEocm91dGVDb25maWcsIHsgLi4uZGF0YSB9KTtcblxuICAgIHJldHVybiB7IHBhdGgsIGJyZWFkY3J1bWIgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RnJvbVN0b3JlKGJyZWFkY3J1bWJBbGlhczogc3RyaW5nLCByb3V0ZUxpbms6IHN0cmluZyk6IEJyZWFkY3J1bWIge1xuICAgIGxldCBtYXRjaGluZ0l0ZW07XG4gICAgaWYgKGJyZWFkY3J1bWJBbGlhcykge1xuICAgICAgbWF0Y2hpbmdJdGVtID0gdGhpcy5keW5hbWljQnJlYWRjcnVtYlN0b3JlLmZpbmQoaXRlbSA9PiBpdGVtLmFsaWFzID09PSBicmVhZGNydW1iQWxpYXMpO1xuICAgIH1cblxuICAgIGlmICghbWF0Y2hpbmdJdGVtICYmIHJvdXRlTGluaykge1xuICAgICAgbWF0Y2hpbmdJdGVtID0gdGhpcy5keW5hbWljQnJlYWRjcnVtYlN0b3JlLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiAoaXRlbS5yb3V0ZUxpbmsgJiYgaXRlbS5yb3V0ZUxpbmsgPT09IHJvdXRlTGluaykgfHwgKGl0ZW0ucm91dGVSZWdleCAmJiBuZXcgUmVnRXhwKGl0ZW0ucm91dGVSZWdleCkudGVzdChyb3V0ZUxpbmsgKyAnLycpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGluZ0l0ZW0gfHwge307XG4gIH1cblxuICAvKipcbiAgICogVG8gdXBkYXRlIGJyZWFkY3J1bWIgbGFiZWwgZm9yIGEgcm91dGUgd2l0aCBwYXRoIHBhcmFtLCB3ZSBuZWVkIHJlZ2V4IHRoYXQgbWF0Y2hlcyByb3V0ZS5cbiAgICogSW5zdGVhZCBvZiB1c2VyIHByb3ZpZGluZyByZWdleCwgd2UgaGVscCBpbiBwcmVwYXJpbmcgcmVnZXggZHluYW1pY2FsbHlcbiAgICpcbiAgICogRXg6IHJvdXRlIGRlY2xhcmF0aW9uIC0gcGF0aDogJy9tZW50b3IvOmlkJ1xuICAgKiBicmVhZGNydW1iU2VydmljZS5zZXQoJy9tZW50b3IvOmlkJywgJ1VkYXknKTtcbiAgICogJy9tZW50b3IvMicgT1IgJ21lbnRvci9hZGEnIHdlIHNob3VsZCB1c2UgJ1VkYXknIGFzIGxhYmVsXG4gICAqXG4gICAqIHJlZ2V4IHN0cmluZyBpcyBidWlsdCwgaWYgcm91dGUgaGFzIHBhdGggcGFyYW1zKGNvbnRhaW5zIHdpdGggJzonKVxuICAgKi9cbiAgcHJpdmF0ZSBidWlsZFJvdXRlUmVnRXhwKHBhdGgpIHtcbiAgICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaCBpcyBwcm92aWRlZCBpbiB0aGUgcGF0aFxuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIHBhdGggPSAnLycgKyBwYXRoO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmluY2x1ZGVzKHRoaXMucGF0aFBhcmFtUHJlZml4KSkge1xuICAgICAgLy8gcmVwbGFjZSBtYXRoaW5nIHBhdGggcGFyYW0gd2l0aCBhIHJlZ2V4XG4gICAgICAvLyAnL21lbnRvci86aWQnIGJlY29tZXMgJy9tZW50b3IvW14vXScsIHdoaWNoIGZ1cnRoZXIgd2lsbCBiZSBtYXRjaGVkIGluIHVwZGF0ZVN0b3JlXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5wYXRoUGFyYW1SZWdleElkZW50aWZpZXIsICdnJyksIHRoaXMucGF0aFBhcmFtUmVnZXhSZXBsYWNlcik7XG4gICAgICByZXR1cm4geyByb3V0ZVJlZ2V4IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHJvdXRlTGluazogcGF0aCB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY3VycmVudCBicmVhZGNydW1iIGRlZmluaXRpb24gYW5kIGVtaXQgYSBuZXcgc3RyZWFtIG9mIGJyZWFkY3J1bWJzXG4gICAqIEFsc28gdXBkYXRlIHRoZSBzdG9yZSB0byByZXVzZSBkeW5hbWljIGRlY2xhcmF0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVTdG9yZShicmVhZGNydW1iKSB7XG4gICAgY29uc3QgeyBicmVhZGNydW1iSXRlbUluZGV4LCBzdG9yZUl0ZW1JbmRleCB9ID0gdGhpcy5nZXRCcmVhZGNydW1iSW5kZXhlcyhicmVhZGNydW1iKTtcblxuICAgIC8vIGlmIGJyZWFkY3J1bWIgaXMgcHJlc2VudCBpbiBjdXJyZW50IGJyZWFkY3J1bWJzIHVwZGF0ZSBpdCBhbmQgZW1pdCBuZXcgc3RyZWFtXG4gICAgaWYgKGJyZWFkY3J1bWJJdGVtSW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jdXJyZW50QnJlYWRjcnVtYnNbYnJlYWRjcnVtYkl0ZW1JbmRleF0gPSB7IC4uLnRoaXMuY3VycmVudEJyZWFkY3J1bWJzW2JyZWFkY3J1bWJJdGVtSW5kZXhdLCAuLi5icmVhZGNydW1iIH07XG4gICAgICBjb25zdCBicmVhZGNydW1ic1RvU2hvdyA9IHRoaXMuY3VycmVudEJyZWFkY3J1bWJzLmZpbHRlcihpdGVtID0+ICFpdGVtLnNraXApO1xuICAgICAgdGhpcy5icmVhZGNydW1icy5uZXh0KFsuLi5icmVhZGNydW1ic1RvU2hvd10pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzdG9yZSBhbHJlYWR5IGhhcyB0aGlzIHJvdXRlIGRlZmluaXRpb24gdXBkYXRlIGl0LCBlbHNlIGFkZFxuICAgIGlmIChzdG9yZUl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmR5bmFtaWNCcmVhZGNydW1iU3RvcmVbc3RvcmVJdGVtSW5kZXhdID0geyAuLi50aGlzLmR5bmFtaWNCcmVhZGNydW1iU3RvcmVbc3RvcmVJdGVtSW5kZXhdLCAuLi5icmVhZGNydW1iIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHluYW1pY0JyZWFkY3J1bWJTdG9yZS5wdXNoKGJyZWFkY3J1bWIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0QnJlYWRjcnVtYkluZGV4ZXMoYnJlYWRjcnVtYik6IGFueSB7XG4gICAgY29uc3QgeyBhbGlhcywgcm91dGVMaW5rLCByb3V0ZVJlZ2V4IH0gPSBicmVhZGNydW1iO1xuICAgIGxldCBpbmRleE1hcCA9IHt9O1xuICAgIC8vIGlkZW50aWZ5IG1hY3RoaW5nIGJyZWFkY3J1bWIgYW5kIHN0b3JlIGl0ZW1cbiAgICBpZiAoYWxpYXMpIHtcbiAgICAgIGluZGV4TWFwID0gdGhpcy5nZXRCcmVhZGNydW1iSW5kZXhlc0J5VHlwZSgnYWxpYXMnLCBhbGlhcyk7XG4gICAgfSBlbHNlIGlmIChyb3V0ZUxpbmspIHtcbiAgICAgIGluZGV4TWFwID0gdGhpcy5nZXRCcmVhZGNydW1iSW5kZXhlc0J5VHlwZSgncm91dGVMaW5rJywgcm91dGVMaW5rKTtcbiAgICB9IGVsc2UgaWYgKHJvdXRlUmVnZXgpIHtcbiAgICAgIGluZGV4TWFwID0gdGhpcy5nZXRCcmVhZGNydW1iSW5kZXhlc0J5VHlwZSgncm91dGVSZWdleCcsIHJvdXRlUmVnZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXhNYXA7XG4gIH1cblxuICBwcml2YXRlIGdldEJyZWFkY3J1bWJJbmRleGVzQnlUeXBlKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgbGV0IGJyZWFkY3J1bWJJdGVtSW5kZXg6IG51bWJlcjtcbiAgICBpZiAoa2V5ICE9PSAncm91dGVSZWdleCcpIHtcbiAgICAgIGJyZWFkY3J1bWJJdGVtSW5kZXggPSB0aGlzLmN1cnJlbnRCcmVhZGNydW1icy5maW5kSW5kZXgoaXRlbSA9PiB2YWx1ZSA9PT0gaXRlbVtrZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWRjcnVtYkl0ZW1JbmRleCA9IHRoaXMuY3VycmVudEJyZWFkY3J1bWJzLmZpbmRJbmRleChpdGVtID0+IG5ldyBSZWdFeHAodmFsdWUpLnRlc3QoaXRlbS5yb3V0ZUxpbmspKTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVJdGVtSW5kZXggPSB0aGlzLmR5bmFtaWNCcmVhZGNydW1iU3RvcmUuZmluZEluZGV4KGl0ZW0gPT4gdmFsdWUgPT09IGl0ZW1ba2V5XSk7XG5cbiAgICByZXR1cm4geyBicmVhZGNydW1iSXRlbUluZGV4LCBzdG9yZUl0ZW1JbmRleCB9O1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlUGF0aFBhcmFtKHBhdGg6IHN0cmluZywgYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlKSB7XG4gICAgLy8gaWYgdGhlIHBhdGggc2VnbWVudCBpcyBhIHJvdXRlIHBhcmFtLCByZWFkIHRoZSBwYXJhbSB2YWx1ZSBmcm9tIHVybFxuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgodGhpcy5wYXRoUGFyYW1QcmVmaXgpKSB7XG4gICAgICByZXR1cm4gYWN0aXZhdGVkUm91dGUuc25hcHNob3QucGFyYW1zW3BhdGguc2xpY2UoMSldO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZVF1ZXJ5UGFyYW0ocm91dGVMaW5rOiBzdHJpbmcsIGFjdGl2YXRlZFJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzQnJlYWRjcnVtYiA9IHRoaXMucHJldmlvdXNCcmVhZGNydW1icy5maW5kKGl0ZW0gPT4gaXRlbS5yb3V0ZUxpbmsgPT09IHJvdXRlTGluaykgfHwge307XG4gICAgY29uc3QgeyBxdWVyeVBhcmFtcywgZnJhZ21lbnQgfSA9IGFjdGl2YXRlZFJvdXRlLnNuYXBzaG90O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXJ5UGFyYW1zOiBPYmplY3Qua2V5cyhxdWVyeVBhcmFtcykubGVuZ3RoID4gMCA/IHsgLi4ucXVlcnlQYXJhbXMgfSA6IHByZXZpb3VzQnJlYWRjcnVtYi5xdWVyeVBhcmFtcyxcbiAgICAgIGZyYWdtZW50OiBmcmFnbWVudCB8fCBwcmV2aW91c0JyZWFkY3J1bWIuZnJhZ21lbnRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBlbXB0eSBjaGlsZHJlbiBvZiBhIG1vZHVsZSBvciBDb21wb25lbnQuIEVtcHR5IGNoaWxkIGlzIHRoZSBvbmUgd2l0aCBwYXRoOiAnJ1xuICAgKiBXaGVuIHBhcmVudCBhbmQgaXQncyBjaGlsZHJlbiAodGhhdCBoYXMgZW1wdHkgcm91dGUgcGF0aCkgZGVmaW5lIGRhdGFcbiAgICogbWVyZ2UgdGhlbSBib3RoIHdpdGggY2hpbGQgdGFraW5nIHByZWNlZGVuY2VcbiAgICovXG4gIHByaXZhdGUgbWVyZ2VXaXRoQmFzZUNoaWxkRGF0YShyb3V0ZUNvbmZpZywgZGF0YSk6IEJyZWFkY3J1bWIge1xuICAgIGlmICghcm91dGVDb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJyZWFkY3J1bWJPcHRpb25zKGRhdGEpO1xuICAgIH1cblxuICAgIGxldCBiYXNlQ2hpbGQ7XG4gICAgaWYgKHJvdXRlQ29uZmlnLmxvYWRDaGlsZHJlbikge1xuICAgICAgLy8gVG8gaGFuZGxlIGEgbW9kdWxlIHdpdGggZW1wdHkgY2hpbGQgcm91dGVcbiAgICAgIGJhc2VDaGlsZCA9IHJvdXRlQ29uZmlnLl9sb2FkZWRDb25maWcucm91dGVzLmZpbmQocm91dGUgPT4gcm91dGUucGF0aCA9PT0gJycpO1xuICAgIH0gZWxzZSBpZiAocm91dGVDb25maWcuY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRvIGhhbmRsZSBhIGNvbXBvbmVudCB3aXRoIGVtcHR5IGNoaWxkIHJvdXRlXG4gICAgICBiYXNlQ2hpbGQgPSByb3V0ZUNvbmZpZy5jaGlsZHJlbi5maW5kKHJvdXRlID0+IHJvdXRlLnBhdGggPT09ICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUNoaWxkICYmIGJhc2VDaGlsZC5kYXRhXG4gICAgICA/IHRoaXMubWVyZ2VXaXRoQmFzZUNoaWxkRGF0YShiYXNlQ2hpbGQsIHtcbiAgICAgICAgICAuLi50aGlzLmdldEJyZWFkY3J1bWJPcHRpb25zKGRhdGEpLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0QnJlYWRjcnVtYk9wdGlvbnMoYmFzZUNoaWxkLmRhdGEpXG4gICAgICAgIH0pXG4gICAgICA6IHRoaXMuZ2V0QnJlYWRjcnVtYk9wdGlvbnMoZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlQXJndW1lbnRzKHBhdGhPckFsaWFzLCBicmVhZGNydW1iKSB7XG4gICAgaWYgKHBhdGhPckFsaWFzID09PSBudWxsIHx8IHBhdGhPckFsaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZmlyc3QgYXJndW1lbnQuIFBsZWFzZSBwYXNzIGEgcm91dGUgcGF0aCBvciBhIGJyZWFkY3J1bWIgYWxpYXMuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChicmVhZGNydW1iID09PSBudWxsIHx8IGJyZWFkY3J1bWIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBzZWNvbmQgYXJndW1lbnQuIFBsZWFzZSBwYXNzIGEgc3RyaW5nIG9yIGFuIE9iamVjdCB3aXRoIGJyZWFkY3J1bWIgb3B0aW9ucy4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogYnJlYWRjcnVtYiBjYW4gYmUgcGFzc2VkIGEgbGFiZWwgb3IgYW4gb3B0aW9ucyBvYmplY3RcbiAgICogSWYgcGFzc2VkIGFzIGEgc3RyaW5nIGNvbnZlcnQgdG8gYnJlYWRjcnVtYiBvcHRpb25zIG9iamVjdFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRCcmVhZGNydW1iT3B0aW9ucyhkYXRhKSB7XG4gICAgbGV0IHsgYnJlYWRjcnVtYiB9ID0gZGF0YTtcbiAgICBpZiAodHlwZW9mIGJyZWFkY3J1bWIgPT09ICdzdHJpbmcnIHx8ICFicmVhZGNydW1iKSB7XG4gICAgICBicmVhZGNydW1iID0ge1xuICAgICAgICBsYWJlbDogYnJlYWRjcnVtYlxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJyZWFkY3J1bWI7XG4gIH1cbn1cbiJdfQ==